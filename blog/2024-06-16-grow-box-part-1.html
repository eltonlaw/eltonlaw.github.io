<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/rm0454__124-clock-tree.png "/><link rel="preload" as="image" href="/mb1360-g070rb_schematic__5.png"/><link rel="stylesheet" href="/_next/static/css/5d82fb85d7740057.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/bd17e4652862e3d3.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c82ad99222c6145b.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-d03af0e963d7a2f3.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-02072d3a2eb6f573.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-b262cd48234fe111.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-92aea3426083640b.js" async=""></script><script src="/_next/static/chunks/app/blog/page-3b1d09e20916cf9b.js" async=""></script><title>eltonlaw</title><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><div class="RootLayout_container__tH3RP"><div class="RootLayout_masthead__LsRd7"><h3><a class="RootLayout_titleLink__VQPJ9" href="/">eltonlaw</a><small> sundries</small></h3><a class="RootLayout_titleLink__VQPJ9" href="https://github.com/eltonlaw"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg></a></div><div class="postFrontmatter"><h2 class="PostFrontmatter_postTitle__fY2bg">Building a Grow Box Part 1 - STM32 basics: Getting to blinky with CMSIS</h2><span class="PostFrontmatter_postDate__ncWjv">2024-06-16 01:19AM</span></div>
<p>I&#x27;ve been using the STM32CubeIDE to build and flash the firmware, it&#x27;s not bad and it works but I have a few issues. Why doesn&#x27;t flashing the device have a keyboard shortcut? As a former front end developer I need to click this button every 10 seconds or I&#x27;ll die. Hot reloading and access to a REPL have ruined me. There are other quality of life issues I have, but these could possibly be chalked up to user error since I&#x27;m a crusty fart about Vim and half my brain is permanently occupied by keybindings. The IDE doesn&#x27;t run on my laptop for some reason (possibly an incompatibility with Wayland). I don&#x27;t like the idea of tying the build process to closely to the IDE because then the repo is a lot more dependent on the local system and CI is hard to setup. I&#x27;m not sure what&#x27;s happening to the code during the build process.</p>
<p>So I decided to build a simpler project with just Make and the <a href="https://github.com/STMicroelectronics/STM32CubeG0">ST provided CMSIS</a> for the G070. CMSIS (Cortex Microcontroller Software Interface Standard) is a vendor-independent hardware abstraction layer for the ARM Cortex processor series. You can&#x27;t simply use the code for one processor for some other processor but there are standardized software APIs for system initialization and configuration and so on. Interactions with the CPU will be through bit twiddling registers. I like reading datasheets, makes me feel like a real engineer.</p>
<p>The STM32G070RB is a 32-bit Cortex M0+ CPU which means it implements the ARMv6-M instruction set, this is not the same as the ARMv6 Thumb instruction set though they are closely aligned. To start, we&#x27;ll build and flash a simple blinky using the built-in LED on the <a href="https://www.digikey.ca/en/products/detail/stmicroelectronics/NUCLEO-G070RB/9861521">Nucleo dev board</a> I&#x27;m working with. At a high level:</p>
<ol>
<li>Hook up a cross compilation toolchain into Make</li>
<li>Compile some code that does the following:<!-- -->
<ol>
<li>Initialize the system clock, we&#x27;ll need it to implement the equivalent of <code>time.sleep(ms: int)</code></li>
<li>Initialize the GPIO peripherals being used</li>
<li>Configure the pin the LED is connected to for output (from the schematic, GPIO PORT A, PIN5)</li>
<li>Loop forever: toggle pin, wait 1 second</li>
</ol>
</li>
<li>Flash to device</li>
</ol>
<h3>Cross-compiling and linking the binary</h3>
<p>Grab the CMSIS files:</p>
<pre><code class="hljs language-bash">git submodule add git@github.com:STMicroelectronics/STM32CubeG0.git 
</code></pre>
<p>It&#x27;s a standard C compile, but using the ARM toolchain:</p>
<pre><code class="hljs language-Makefile">CC=arm-none-eabi-gcc
CFLAGS=-mcpu=cortex-m0plus -mthumb -g -O0
CFLAGS+=-I./STM32CubeG0/Drivers/CMSIS/Device/ST/STM32G0xx/Include
CFLAGS+=-I./STM32CubeG0/Drivers/CMSIS/Include
CFLAGS+=-I./src
LDFLAGS=-Tlinker_script.ld -nostartfiles
OBJCOPY=arm-none-eabi-objcopy

SRC = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.c)</span>

<span class="hljs-section">all: main.bin</span>

<span class="hljs-section">main.bin: main.elf</span>
	<span class="hljs-variable">$(OBJCOPY)</span> -O binary <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$@</span>

<span class="hljs-section">main.elf: <span class="hljs-variable">$(SRC)</span></span>
	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(LDFLAGS)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span>

<span class="hljs-section">clean:</span>
	rm -f *.elf *.bin

<span class="hljs-section">flash: main.bin</span>
	STM32_Programmer_CLI -c port=SWD -w main.bin 0x8000000 -rst
</code></pre>
<p>The <code>flash</code> recipe at the end writes the final binary file to where flash memory starts on the processor (found in the datasheet). The processor is connected to an intermediary device (ST-LINK) by two pins SWCLK (serial wire clock) and SWDIO (serial wire data I/O), this is a debug interface called SWD. This intermediary device bridges SWD to USB-B and that&#x27;s what talks to the <code>STM32_Programmer_CLI</code></p>
<p>The source file <code>src/main.c</code> will just be a no-op for now.</p>
<pre><code class="hljs language-C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STM32G070xx</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32g0xx.h&quot;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) { }
}
</code></pre>
<p><code>#define STM32G070xx</code> is needed because <code>#include &quot;stm32g0xx.h&quot;</code> is a wrapper header file for the the entire G0 family, including the processor-specific headers only when the a processor specific define exists. Adding <code>#define STM32G070xx</code> links in <code>STM32CubeG0/Drivers/CMSIS/Device/ST/STM32G0xx/Include/stm32g070xx.h</code> (from the CMSIS git submodule earlier) which has all the register and bit definitions, address mappings and structs needed to use the peripherals. This way we don&#x27;t have to write binary directly, but can bit bang with definitions.</p>
<h3>Stepping through the program</h3>
<p>On-chip debugging is a way to run, pause and inspect the state of the hardware as your code runs. As mentioned previously, the STM32G070 has a SWD interface, providing the pins SWDIO and SWCLK. The nucleo board I&#x27;m using has an ST-LINK interface on it, a separate chip, which is what manages the USB connection to the computer. This is physically wired to the SWDIO and SWCLK on the microcontroller and USB commands are converted to the appropriate signals on those pins.</p>
<p>In practise, <a href="https://openocd.org/pages/documentation.html">OpenOCD</a> starts a server that connects to the microcontroller and client programs (GDB, telnet or TCL) control the microcontroller through it. The server needs to be configured so it can properly send and receive data but there&#x27;s a <a href="https://github.com/openocd-org/openocd/tree/e4c0904731320c686e5074e68db8358e2f3ce83d/tcl">bunch of standard configurations provided on GitHub</a>, so after cloning that repo, starting the OpenOCD server, for my setup:</p>
<pre><code class="hljs language-bash">openocd -f interface/stlink.cfg -f target/stm32g0x.cfg  -s $(<span class="hljs-built_in">pwd</span>)/openocd/tcl
</code></pre>
<p>Start a GDB server</p>
<pre><code class="hljs language-bash">arm-none-eabi-gdb main.elf
</code></pre>
<p>Connect GDB server to OpenOCD server, and load the program.</p>
<pre><code class="hljs language-gdb">target remote :3333
load
monitor halt
monitor reset init
</code></pre>
<p>Testing the connection with:</p>
<pre><code class="hljs language-C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">int</span> x;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        x = add(x, <span class="hljs-number">3</span>);
    }
}
</code></pre>
<p>...And stepping through it shows <code>x += 3</code> each loop indicating the code has compiled and flashed correctly!</p>
<pre><code class="hljs language-gdb">(gdb) break main
Breakpoint 1 at 0x800010e: file src/main.c, line 19.
Note: automatically using hardware breakpoints for read-only addresses.
(gdb) continue
Continuing.

Breakpoint 1, main () at src/main.c:19
19          int x = 0;
(gdb) step
halted: PC: 0x08000110
halted: PC: 0x08000112
21              x = add(x, 3);
(gdb) step
halted: PC: 0x08000114
halted: PC: 0x08000116
halted: PC: 0x08000118
halted: PC: 0x08000248
add (a=0, b=3) at src/gpio.c:2
2               return a + b;
(gdb) step
halted: PC: 0x08000254
halted: PC: 0x08000256
halted: PC: 0x08000258
3       }
(gdb) step
halted: PC: 0x0800025a
halted: PC: 0x0800025c
halted: PC: 0x0800025e
halted: PC: 0x0800011c
halted: PC: 0x0800011e
halted: PC: 0x08000120
halted: PC: 0x08000112
halted: PC: 0x08000114
halted: PC: 0x08000116
halted: PC: 0x08000118
halted: PC: 0x08000248
add (a=3, b=3) at src/gpio.c:2
2               return a + b;
</code></pre>
<p>With each step, the accumulator var <code>a</code> is increasing by 3, as expected, so we have some C code properly executing additions on the chip now. To interact with the physical world, we&#x27;ll need a little more setup.</p>
<h3>ARMv6-M</h3>
<h3>Initializing the System Clock</h3>
<img src="/rm0454__124-clock-tree.png "/>
<p>The primary clock source can be set as one of HSI16 RC (high speed integrated 16Mhz), HSE OSC (high speed external clock source), LSI RC (low speed integrated 32Khz), LSE OSC (low speed external clock source), I2S_CKIN (I2S1 peripheral).</p>
<p>Based on whichever one is picked, that becomes the base and affects all the secondary clock signals that derive from it with some prescale divider.</p>
<blockquote>
<p>Upon system reset, the HSISYS clock derived from HSI16 oscillator is selected as system clock.</p>
</blockquote>
<p>By default, the base processor clock is set at 16MHz. In the CMSIS, RCC (Reset and Clock Control) is what manages system and peripheral clocks. These are all the registers avaialable, they each map to some physical entity in the hardware:</p>
<pre><code class="hljs language-C"><span class="hljs-comment">/**
  * @brief Reset and Clock Control
  */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
  __IO <span class="hljs-type">uint32_t</span> CR;          <span class="hljs-comment">/*!&lt; RCC Clock Sources Control Register,                                     Address offset: 0x00 */</span>
  __IO <span class="hljs-type">uint32_t</span> ICSCR;       <span class="hljs-comment">/*!&lt; RCC Internal Clock Sources Calibration Register,                        Address offset: 0x04 */</span>
  __IO <span class="hljs-type">uint32_t</span> CFGR;        <span class="hljs-comment">/*!&lt; RCC Regulated Domain Clocks Configuration Register,                     Address offset: 0x08 */</span>
  __IO <span class="hljs-type">uint32_t</span> PLLCFGR;     <span class="hljs-comment">/*!&lt; RCC System PLL configuration Register,                                  Address offset: 0x0C */</span>
  __IO <span class="hljs-type">uint32_t</span> RESERVED0;   <span class="hljs-comment">/*!&lt; Reserved,                                                               Address offset: 0x10 */</span>
  __IO <span class="hljs-type">uint32_t</span> RESERVED1;   <span class="hljs-comment">/*!&lt; Reserved,                                                               Address offset: 0x14 */</span>
  __IO <span class="hljs-type">uint32_t</span> CIER;        <span class="hljs-comment">/*!&lt; RCC Clock Interrupt Enable Register,                                    Address offset: 0x18 */</span>
  __IO <span class="hljs-type">uint32_t</span> CIFR;        <span class="hljs-comment">/*!&lt; RCC Clock Interrupt Flag Register,                                      Address offset: 0x1C */</span>
  __IO <span class="hljs-type">uint32_t</span> CICR;        <span class="hljs-comment">/*!&lt; RCC Clock Interrupt Clear Register,                                     Address offset: 0x20 */</span>
  __IO <span class="hljs-type">uint32_t</span> IOPRSTR;     <span class="hljs-comment">/*!&lt; RCC IO port reset register,                                             Address offset: 0x24 */</span>
  __IO <span class="hljs-type">uint32_t</span> AHBRSTR;     <span class="hljs-comment">/*!&lt; RCC AHB peripherals reset register,                                     Address offset: 0x28 */</span>
  __IO <span class="hljs-type">uint32_t</span> APBRSTR1;    <span class="hljs-comment">/*!&lt; RCC APB peripherals reset register 1,                                   Address offset: 0x2C */</span>
  __IO <span class="hljs-type">uint32_t</span> APBRSTR2;    <span class="hljs-comment">/*!&lt; RCC APB peripherals reset register 2,                                   Address offset: 0x30 */</span>
  __IO <span class="hljs-type">uint32_t</span> IOPENR;      <span class="hljs-comment">/*!&lt; RCC IO port enable register,                                            Address offset: 0x34 */</span>
  __IO <span class="hljs-type">uint32_t</span> AHBENR;      <span class="hljs-comment">/*!&lt; RCC AHB peripherals clock enable register,                              Address offset: 0x38 */</span>
  __IO <span class="hljs-type">uint32_t</span> APBENR1;     <span class="hljs-comment">/*!&lt; RCC APB peripherals clock enable register1,                             Address offset: 0x3C */</span>
  __IO <span class="hljs-type">uint32_t</span> APBENR2;     <span class="hljs-comment">/*!&lt; RCC APB peripherals clock enable register2,                             Address offset: 0x40 */</span>
  __IO <span class="hljs-type">uint32_t</span> IOPSMENR;    <span class="hljs-comment">/*!&lt; RCC IO port clocks enable in sleep mode register,                       Address offset: 0x44 */</span>
  __IO <span class="hljs-type">uint32_t</span> AHBSMENR;    <span class="hljs-comment">/*!&lt; RCC AHB peripheral clocks enable in sleep mode register,                Address offset: 0x48 */</span>
  __IO <span class="hljs-type">uint32_t</span> APBSMENR1;   <span class="hljs-comment">/*!&lt; RCC APB peripheral clocks enable in sleep mode register1,               Address offset: 0x4C */</span>
  __IO <span class="hljs-type">uint32_t</span> APBSMENR2;   <span class="hljs-comment">/*!&lt; RCC APB peripheral clocks enable in sleep mode register2,               Address offset: 0x50 */</span>
  __IO <span class="hljs-type">uint32_t</span> CCIPR;       <span class="hljs-comment">/*!&lt; RCC Peripherals Independent Clocks Configuration Register,              Address offset: 0x54 */</span>
  __IO <span class="hljs-type">uint32_t</span> RESERVED2;   <span class="hljs-comment">/*!&lt; Reserved,                                                               Address offset: 0x58 */</span>
  __IO <span class="hljs-type">uint32_t</span> BDCR;        <span class="hljs-comment">/*!&lt; RCC Backup Domain Control Register,                                     Address offset: 0x5C */</span>
  __IO <span class="hljs-type">uint32_t</span> CSR;         <span class="hljs-comment">/*!&lt; RCC Unregulated Domain Clock Control and Status Register,               Address offset: 0x60 */</span>
} RCC_TypeDef;
</code></pre>
<p>SysTick is a standard component of the ARM Cortex-M cores and can be used for context switching or implementing sleep/delay functions among other things. It is a 24-bit clear-on-write timer that has some initial value and decrements every clock cycle. When it hits 0 it&#x27;ll generate a SysTick interrupt. There&#x27;s a provided function for configuring this already:</p>
<pre><code class="hljs language-C">__STATIC_INLINE <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">SysTick_Config</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> ticks)</span>
{
  <span class="hljs-keyword">if</span> ((ticks - <span class="hljs-number">1UL</span>) &gt; SysTick_LOAD_RELOAD_Msk)
  {
    <span class="hljs-keyword">return</span> (<span class="hljs-number">1UL</span>);                                                   <span class="hljs-comment">/* Reload value impossible */</span>
  }

  SysTick-&gt;LOAD  = (<span class="hljs-type">uint32_t</span>)(ticks - <span class="hljs-number">1UL</span>);                         <span class="hljs-comment">/* set reload register */</span>
  NVIC_SetPriority (SysTick_IRQn, (<span class="hljs-number">1UL</span> &lt;&lt; __NVIC_PRIO_BITS) - <span class="hljs-number">1UL</span>); <span class="hljs-comment">/* set Priority for Systick Interrupt */</span>
  SysTick-&gt;VAL   = <span class="hljs-number">0UL</span>;                                             <span class="hljs-comment">/* Load the SysTick Counter Value */</span>
  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         <span class="hljs-comment">/* Enable SysTick IRQ and SysTick Timer */</span>
  <span class="hljs-keyword">return</span> (<span class="hljs-number">0UL</span>);                                                     <span class="hljs-comment">/* Function successful */</span>
}
</code></pre>
<ul>
<li><code>ticks</code> is the number of clock ticks per interrupt.</li>
<li><code>SysTick-&gt;VAL</code> is the tick counter and it gets set to 0 so that we&#x27;re at known state.</li>
<li><code>SysTick_CTRL_TICKINT_Msk</code> is a uint32 with just the bit that enables the SysTick interrupt set to 1</li>
<li><code>SysTick_CTRL_ENABLE_Msk</code> is a uint32 with just the bit that enables decrementing <code>SysTick-&gt;VAL</code></li>
<li><code>SysTick_CTRL_CLKSOURCE_Msk</code> is a uint32 with just the bit that sets the processor clock as source for the SysTick timer</li>
<li>Oddly in the ST provided HAL, there&#x27;s a <code>__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)</code> called as part of <code>HAL_StatusTypeDef HAL_Init(void)</code> and it&#x27;s passing in <code>#define  TICK_INT_PRIORITY            0U</code>, setting it to 0 (highest priority) whereas CMSIS is setting it as 3 (lowest priority, it&#x27;s a 2 bit value). So as is, SysTick stuff will be less accurate if there&#x27;s a lot of higher priority interrupts generated. I&#x27;ll leave it as is for now.</li>
</ul>
<p>Earlier, we saw that the processor clock was set at 16 MHz and 16MHz is 16 million cycles per second, 1ms is 0.001 seconds, therefore 16000 cycles would be 1ms. So to setup SysTick for 1ms per tick:</p>
<pre><code class="hljs language-C">SysTick_Config(<span class="hljs-number">16000</span>);
SystemCoreClockUpdate();
</code></pre>
<p>We need to call <code>SystemCoreClockUpdate</code> because <code>SysTick_Config</code> only changes the register values but <code>SystemCoreClockUpdate()</code> ensures that the global variable <code>SystemCoreClock</code> is updated to reflect the current core clock frequency.</p>
<p>One last thing, when enabling interrupts, it&#x27;s important to define their associated handlers. From the device specific <code>startup.s</code> file, all interrupts handlers are declared as weak symbols that default to a <code>Default_Handler</code> which is a no-op infinite loop.</p>
<pre><code class="hljs language-armasm">...
.global Default_Handler

  ...
  .section .text.Default_Handler,&quot;ax&quot;,%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
  .size Default_Handler, .-Default_Handler

  ...
  .weak      SysTick_Handler
  .thumb_set SysTick_Handler,Default_Handler
</code></pre>
<p>So if SysTick is enabled and generates an interrupt without a definitive definition of <code>SysTick_Handler</code>, it&#x27;ll hang forever. Since we&#x27;ve configured it to hit 0 every 1ms, simply incrementing a number every interrupt counts the milliseconds since initialization.</p>
<pre><code class="hljs language-C"><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> uw_tick = <span class="hljs-number">0</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    uw_tick++;
}
</code></pre>
<p>At a rate of a tick per 1 ms, it&#x27;ll only overflow after 2^32 or 4,294,967,296 ms (~49.71 days). Overflow will be handled later, but since this code will be called in such a tight loop, logic will instead be put into everything that uses <code>uw_tick</code>.</p>
<h3>GPIO configuration</h3>
<p>On the nucleo board, there&#x27;s a green LED, LD4 connected to PA5.</p>
<img src="/mb1360-g070rb_schematic__5.png"/>
<p>To get that to blink, the GPIO pin needs to be configured for output. All peripherals are disabled by default, so first the GPIO clock needs to be enabled, this is managed by RCC.</p>
<pre><code class="hljs language-C">RCC-&gt;IOPENR |= RCC_IOPENR_GPIOAEN;
<span class="hljs-comment">/* Ensure clock is enabled by read op */</span>
<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> tmpreg = RCC-&gt;IOPENR &amp; RCC_IOPENR_GPIOAEN;
(<span class="hljs-type">void</span>) tmpreg; <span class="hljs-comment">/* avoid compiler warnings about unused var */</span>
</code></pre>
<p>The relevant global struct that deals with that is <code>GPIOA</code> defined in <code>STM32CubeG0/Drivers/CMSIS/Device/ST/STM32G0xx/Include/stm32g070xx.h</code></p>
<pre><code class="hljs language-C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)</span>
...
<span class="hljs-comment">/**
  * @brief General Purpose I/O
  */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
  __IO <span class="hljs-type">uint32_t</span> MODER;       <span class="hljs-comment">/*!&lt; GPIO port mode register,               Address offset: 0x00      */</span>
  __IO <span class="hljs-type">uint32_t</span> OTYPER;      <span class="hljs-comment">/*!&lt; GPIO port output type register,        Address offset: 0x04      */</span>
  __IO <span class="hljs-type">uint32_t</span> OSPEEDR;     <span class="hljs-comment">/*!&lt; GPIO port output speed register,       Address offset: 0x08      */</span>
  __IO <span class="hljs-type">uint32_t</span> PUPDR;       <span class="hljs-comment">/*!&lt; GPIO port pull-up/pull-down register,  Address offset: 0x0C      */</span>
  __IO <span class="hljs-type">uint32_t</span> IDR;         <span class="hljs-comment">/*!&lt; GPIO port input data register,         Address offset: 0x10      */</span>
  __IO <span class="hljs-type">uint32_t</span> ODR;         <span class="hljs-comment">/*!&lt; GPIO port output data register,        Address offset: 0x14      */</span>
  __IO <span class="hljs-type">uint32_t</span> BSRR;        <span class="hljs-comment">/*!&lt; GPIO port bit set/reset  register,     Address offset: 0x18      */</span>
  __IO <span class="hljs-type">uint32_t</span> LCKR;        <span class="hljs-comment">/*!&lt; GPIO port configuration lock register, Address offset: 0x1C      */</span>
  __IO <span class="hljs-type">uint32_t</span> AFR[<span class="hljs-number">2</span>];      <span class="hljs-comment">/*!&lt; GPIO alternate function registers,     Address offset: 0x20-0x24 */</span>
  __IO <span class="hljs-type">uint32_t</span> BRR;         <span class="hljs-comment">/*!&lt; GPIO Bit Reset register,               Address offset: 0x28      */</span>
} GPIO_TypeDef;
</code></pre>
<p>And a basic output configuration for Port A, Pin 5:</p>
<pre><code class="hljs language-C"><span class="hljs-comment">/* Configure pin to be output */</span> 
GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODE5;
GPIOA-&gt;MODER |= GPIO_MODER_MODE5_0;

<span class="hljs-comment">/* Clear pin to make pin push-pull mode (as opposed to open drain) */</span> 
GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT5;

<span class="hljs-comment">/* GPIO_OSPEEDR_OSPEED5_0 corresponds to `01` in bit[10:11] of OSPEEDR which means &quot;Low speed&quot;  */</span>
GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDR_OSPEED5;
GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDR_OSPEED5_0;

<span class="hljs-comment">/* Clears the pin5 bits in PUPDR which means no pull-up or pull-down */</span>
GPIOA-&gt;PUPDR &amp;= ~GPIO_PUPDR_PUPD5;
</code></pre>
<p>Once we have this configured, we can run the following in an infinite loop to set pin 5 for a second, clear it for a second</p>
<pre><code class="hljs language-C"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    GPIOA-&gt;BSRR = GPIO_BSRR_BS5;
    delay(<span class="hljs-number">1000</span>);
    GPIOA-&gt;BSRR = GPIO_BSRR_BR5;
    delay(<span class="hljs-number">1000</span>);
}
</code></pre>
<p>and that blinks the light:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mCYVTn8uvUA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe></div><script src="/_next/static/chunks/webpack-c82ad99222c6145b.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/5d82fb85d7740057.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/bd17e4652862e3d3.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"4:I[7690,[],\"\"]\n6:I[5613,[],\"\"]\n7:I[1778,[],\"\"]\n8:I[5250,[\"250\",\"static/chunks/250-92aea3426083640b.js\",\"404\",\"static/chunks/app/blog/page-3b1d09e20916cf9b.js\"],\"\"]\na:I[8955,[],\"\"]\nb:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5d82fb85d7740057.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"DVXerpLq5cqBwuO_WOXGL\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/2024-06-16-grow-box-part-1\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[\"2024-06-16-grow-box-part-1\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[\"2024-06-16-grow-box-part-1\",{\"children\":[\"__PAGE__\",{},[\"$L5\",[[\"$\",\"div\",null,{\"className\":\"postFrontmatter\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"PostFrontmatter_postTitle__fY2bg\",\"children\":\"Building a Grow Box Part 1 - STM32 basics: Getting to blinky with CMSIS\"}],[\"$\",\"span\",null,{\"className\":\"PostFrontmatter_postDate__ncWjv\",\"children\":\"2024-06-16 01:19AM\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I've been using the STM32CubeIDE to build and flash the firmware, it's not bad and it works but I have a few issues. Why doesn't flashing the device have a keyboard shortcut? As a former front end developer I need to click this button every 10 seconds or I'll die. Hot reloading and access to a REPL have ruined me. There are other quality of life issues I have, but these could possibly be chalked up to user error since I'm a crusty fart about Vim and half my brain is permanently occupied by keybindings. The IDE doesn't run on my laptop for some reason (possibly an incompatibility with Wayland). I don't like the idea of tying the build process to closely to the IDE because then the repo is a lot more dependent on the local system and CI is hard to setup. I'm not sure what's happening to the code during the build process.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"So I decided to build a simpler project with just Make and the \",[\"$\",\"a\",null,{\"href\":\"https://github.com/STMicroelectronics/STM32CubeG0\",\"children\":\"ST provided CMSIS\"}],\" for the G070. CMSIS (Cortex Microcontroller Software Interface Standard) is a vendor-independent hardware abstraction layer for the ARM Cortex processor series. You can't simply use the code for one processor for some other processor but there are standardized software APIs for system initialization and configuration and so on. Interactions with the CPU will be through bit twiddling registers. I like reading datasheets, makes me feel like a real engineer.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The STM32G070RB is a 32-bit Cortex M0+ CPU which means it implements the ARMv6-M instruction set, this is not the same as the ARMv6 Thumb instruction set though they are closely aligned. To start, we'll build and flash a simple blinky using the built-in LED on the \",[\"$\",\"a\",null,{\"href\":\"https://www.digikey.ca/en/products/detail/stmicroelectronics/NUCLEO-G070RB/9861521\",\"children\":\"Nucleo dev board\"}],\" I'm working with. At a high level:\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Hook up a cross compilation toolchain into Make\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Compile some code that does the following:\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Initialize the system clock, we'll need it to implement the equivalent of \",[\"$\",\"code\",null,{\"children\":\"time.sleep(ms: int)\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Initialize the GPIO peripherals being used\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Configure the pin the LED is connected to for output (from the schematic, GPIO PORT A, PIN5)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Loop forever: toggle pin, wait 1 second\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Flash to device\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Cross-compiling and linking the binary\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Grab the CMSIS files:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-bash\",\"children\":\"git submodule add git@github.com:STMicroelectronics/STM32CubeG0.git \\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"It's a standard C compile, but using the ARM toolchain:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-Makefile\",\"children\":[\"CC=arm-none-eabi-gcc\\nCFLAGS=-mcpu=cortex-m0plus -mthumb -g -O0\\nCFLAGS+=-I./STM32CubeG0/Drivers/CMSIS/Device/ST/STM32G0xx/Include\\nCFLAGS+=-I./STM32CubeG0/Drivers/CMSIS/Include\\nCFLAGS+=-I./src\\nLDFLAGS=-Tlinker_script.ld -nostartfiles\\nOBJCOPY=arm-none-eabi-objcopy\\n\\nSRC = \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":[\"$$(\",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"wildcard\"}],\" src/*.c)\"]}],\"\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-section\",\"children\":\"all: main.bin\"}],\"\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-section\",\"children\":\"main.bin: main.elf\"}],\"\\n\\t\",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$(OBJCOPY)\"}],\" -O binary \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$\u003c\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$@\"}],\"\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-section\",\"children\":[\"main.elf: \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$(SRC)\"}]]}],\"\\n\\t\",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$(CC)\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$(CFLAGS)\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$(LDFLAGS)\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$^\"}],\" -o \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"$$@\"}],\"\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-section\",\"children\":\"clean:\"}],\"\\n\\trm -f *.elf *.bin\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-section\",\"children\":\"flash: main.bin\"}],\"\\n\\tSTM32_Programmer_CLI -c port=SWD -w main.bin 0x8000000 -rst\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The \",[\"$\",\"code\",null,{\"children\":\"flash\"}],\" recipe at the end writes the final binary file to where flash memory starts on the processor (found in the datasheet). The processor is connected to an intermediary device (ST-LINK) by two pins SWCLK (serial wire clock) and SWDIO (serial wire data I/O), this is a debug interface called SWD. This intermediary device bridges SWD to USB-B and that's what talks to the \",[\"$\",\"code\",null,{\"children\":\"STM32_Programmer_CLI\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The source file \",[\"$\",\"code\",null,{\"children\":\"src/main.c\"}],\" will just be a no-op for now.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-meta\",\"children\":[\"#\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"define\"}],\" STM32G070xx\"]}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-meta\",\"children\":[\"#\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"include\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"stm32g0xx.h\\\"\"}]]}],\"\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"int\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title function_\",\"children\":\"main\"}],[\"$\",\"span\",null,{\"className\":\"hljs-params\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"void\"}],\")\"]}],\" {\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"while\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}],\") { }\\n}\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"#define STM32G070xx\"}],\" is needed because \",[\"$\",\"code\",null,{\"children\":\"#include \\\"stm32g0xx.h\\\"\"}],\" is a wrapper header file for the the entire G0 family, including the processor-specific headers only when the a processor specific define exists. Adding \",[\"$\",\"code\",null,{\"children\":\"#define STM32G070xx\"}],\" links in \",[\"$\",\"code\",null,{\"children\":\"STM32CubeG0/Drivers/CMSIS/Device/ST/STM32G0xx/Include/stm32g070xx.h\"}],\" (from the CMSIS git submodule earlier) which has all the register and bit definitions, address mappings and structs needed to use the peripherals. This way we don't have to write binary directly, but can bit bang with definitions.\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Stepping through the program\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"On-chip debugging is a way to run, pause and inspect the state of the hardware as your code runs. As mentioned previously, the STM32G070 has a SWD interface, providing the pins SWDIO and SWCLK. The nucleo board I'm using has an ST-LINK interface on it, a separate chip, which is what manages the USB connection to the computer. This is physically wired to the SWDIO and SWCLK on the microcontroller and USB commands are converted to the appropriate signals on those pins.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In practise, \",[\"$\",\"a\",null,{\"href\":\"https://openocd.org/pages/documentation.html\",\"children\":\"OpenOCD\"}],\" starts a server that connects to the microcontroller and client programs (GDB, telnet or TCL) control the microcontroller through it. The server needs to be configured so it can properly send and receive data but there's a \",[\"$\",\"a\",null,{\"href\":\"https://github.com/openocd-org/openocd/tree/e4c0904731320c686e5074e68db8358e2f3ce83d/tcl\",\"children\":\"bunch of standard configurations provided on GitHub\"}],\", so after cloning that repo, starting the OpenOCD server, for my setup:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-bash\",\"children\":[\"openocd -f interface/stlink.cfg -f target/stm32g0x.cfg  -s $(\",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"pwd\"}],\")/openocd/tcl\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Start a GDB server\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-bash\",\"children\":\"arm-none-eabi-gdb main.elf\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Connect GDB server to OpenOCD server, and load the program.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-gdb\",\"children\":\"target remote :3333\\nload\\nmonitor halt\\nmonitor reset init\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Testing the connection with:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"int\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title function_\",\"children\":\"main\"}],[\"$\",\"span\",null,{\"className\":\"hljs-params\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"void\"}],\")\"]}],\" {\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"int\"}],\" x;\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"while\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}],\") {\\n        x = add(x, \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"3\"}],\");\\n    }\\n}\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"...And stepping through it shows \",[\"$\",\"code\",null,{\"children\":\"x += 3\"}],\" each loop indicating the code has compiled and flashed correctly!\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-gdb\",\"children\":\"(gdb) break main\\nBreakpoint 1 at 0x800010e: file src/main.c, line 19.\\nNote: automatically using hardware breakpoints for read-only addresses.\\n(gdb) continue\\nContinuing.\\n\\nBreakpoint 1, main () at src/main.c:19\\n19          int x = 0;\\n(gdb) step\\nhalted: PC: 0x08000110\\nhalted: PC: 0x08000112\\n21              x = add(x, 3);\\n(gdb) step\\nhalted: PC: 0x08000114\\nhalted: PC: 0x08000116\\nhalted: PC: 0x08000118\\nhalted: PC: 0x08000248\\nadd (a=0, b=3) at src/gpio.c:2\\n2               return a + b;\\n(gdb) step\\nhalted: PC: 0x08000254\\nhalted: PC: 0x08000256\\nhalted: PC: 0x08000258\\n3       }\\n(gdb) step\\nhalted: PC: 0x0800025a\\nhalted: PC: 0x0800025c\\nhalted: PC: 0x0800025e\\nhalted: PC: 0x0800011c\\nhalted: PC: 0x0800011e\\nhalted: PC: 0x08000120\\nhalted: PC: 0x08000112\\nhalted: PC: 0x08000114\\nhalted: PC: 0x08000116\\nhalted: PC: 0x08000118\\nhalted: PC: 0x08000248\\nadd (a=3, b=3) at src/gpio.c:2\\n2               return a + b;\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"With each step, the accumulator var \",[\"$\",\"code\",null,{\"children\":\"a\"}],\" is increasing by 3, as expected, so we have some C code properly executing additions on the chip now. To interact with the physical world, we'll need a little more setup.\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"ARMv6-M\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Initializing the System Clock\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/rm0454__124-clock-tree.png \"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The primary clock source can be set as one of HSI16 RC (high speed integrated 16Mhz), HSE OSC (high speed external clock source), LSI RC (low speed integrated 32Khz), LSE OSC (low speed external clock source), I2S_CKIN (I2S1 peripheral).\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Based on whichever one is picked, that becomes the base and affects all the secondary clock signals that derive from it with some prescale divider.\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"Upon system reset, the HSISYS clock derived from HSI16 oscillator is selected as system clock.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"By default, the base processor clock is set at 16MHz. In the CMSIS, RCC (Reset and Clock Control) is what manages system and peripheral clocks. These are all the registers avaialable, they each map to some physical entity in the hardware:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/**\\n  * @brief Reset and Clock Control\\n  */\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"typedef\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-class\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\"\\n{\"]}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CR;          \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Clock Sources Control Register,                                     Address offset: 0x00 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" ICSCR;       \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Internal Clock Sources Calibration Register,                        Address offset: 0x04 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CFGR;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Regulated Domain Clocks Configuration Register,                     Address offset: 0x08 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" PLLCFGR;     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC System PLL configuration Register,                                  Address offset: 0x0C */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" RESERVED0;   \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c Reserved,                                                               Address offset: 0x10 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" RESERVED1;   \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c Reserved,                                                               Address offset: 0x14 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CIER;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Clock Interrupt Enable Register,                                    Address offset: 0x18 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CIFR;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Clock Interrupt Flag Register,                                      Address offset: 0x1C */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CICR;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Clock Interrupt Clear Register,                                     Address offset: 0x20 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" IOPRSTR;     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC IO port reset register,                                             Address offset: 0x24 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" AHBRSTR;     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC AHB peripherals reset register,                                     Address offset: 0x28 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" APBRSTR1;    \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC APB peripherals reset register 1,                                   Address offset: 0x2C */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" APBRSTR2;    \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC APB peripherals reset register 2,                                   Address offset: 0x30 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" IOPENR;      \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC IO port enable register,                                            Address offset: 0x34 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" AHBENR;      \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC AHB peripherals clock enable register,                              Address offset: 0x38 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" APBENR1;     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC APB peripherals clock enable register1,                             Address offset: 0x3C */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" APBENR2;     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC APB peripherals clock enable register2,                             Address offset: 0x40 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" IOPSMENR;    \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC IO port clocks enable in sleep mode register,                       Address offset: 0x44 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" AHBSMENR;    \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC AHB peripheral clocks enable in sleep mode register,                Address offset: 0x48 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" APBSMENR1;   \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC APB peripheral clocks enable in sleep mode register1,               Address offset: 0x4C */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" APBSMENR2;   \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC APB peripheral clocks enable in sleep mode register2,               Address offset: 0x50 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CCIPR;       \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Peripherals Independent Clocks Configuration Register,              Address offset: 0x54 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" RESERVED2;   \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c Reserved,                                                               Address offset: 0x58 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" BDCR;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Backup Domain Control Register,                                     Address offset: 0x5C */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" CSR;         \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c RCC Unregulated Domain Clock Control and Status Register,               Address offset: 0x60 */\"}],\"\\n} RCC_TypeDef;\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"SysTick is a standard component of the ARM Cortex-M cores and can be used for context switching or implementing sleep/delay functions among other things. It is a 24-bit clear-on-write timer that has some initial value and decrements every clock cycle. When it hits 0 it'll generate a SysTick interrupt. There's a provided function for configuring this already:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[\"__STATIC_INLINE \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title function_\",\"children\":\"SysTick_Config\"}],[\"$\",\"span\",null,{\"className\":\"hljs-params\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" ticks)\"]}],\"\\n{\\n  \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"if\"}],\" ((ticks - \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1UL\"}],\") \u003e SysTick_LOAD_RELOAD_Msk)\\n  {\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"return\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1UL\"}],\");                                                   \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Reload value impossible */\"}],\"\\n  }\\n\\n  SysTick-\u003eLOAD  = (\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\")(ticks - \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1UL\"}],\");                         \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* set reload register */\"}],\"\\n  NVIC_SetPriority (SysTick_IRQn, (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1UL\"}],\" \u003c\u003c __NVIC_PRIO_BITS) - \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1UL\"}],\"); \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* set Priority for Systick Interrupt */\"}],\"\\n  SysTick-\u003eVAL   = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0UL\"}],\";                                             \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Load the SysTick Counter Value */\"}],\"\\n  SysTick-\u003eCTRL  = SysTick_CTRL_CLKSOURCE_Msk |\\n                   SysTick_CTRL_TICKINT_Msk   |\\n                   SysTick_CTRL_ENABLE_Msk;                         \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Enable SysTick IRQ and SysTick Timer */\"}],\"\\n  \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"return\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0UL\"}],\");                                                     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Function successful */\"}],\"\\n}\\n\"]}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"ticks\"}],\" is the number of clock ticks per interrupt.\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"SysTick-\u003eVAL\"}],\" is the tick counter and it gets set to 0 so that we're at known state.\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"SysTick_CTRL_TICKINT_Msk\"}],\" is a uint32 with just the bit that enables the SysTick interrupt set to 1\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"SysTick_CTRL_ENABLE_Msk\"}],\" is a uint32 with just the bit that enables decrementing \",[\"$\",\"code\",null,{\"children\":\"SysTick-\u003eVAL\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"SysTick_CTRL_CLKSOURCE_Msk\"}],\" is a uint32 with just the bit that sets the processor clock as source for the SysTick timer\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Oddly in the ST provided HAL, there's a \",[\"$\",\"code\",null,{\"children\":\"__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\"}],\" called as part of \",[\"$\",\"code\",null,{\"children\":\"HAL_StatusTypeDef HAL_Init(void)\"}],\" and it's passing in \",[\"$\",\"code\",null,{\"children\":\"#define  TICK_INT_PRIORITY            0U\"}],\", setting it to 0 (highest priority) whereas CMSIS is setting it as 3 (lowest priority, it's a 2 bit value). So as is, SysTick stuff will be less accurate if there's a lot of higher priority interrupts generated. I'll leave it as is for now.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Earlier, we saw that the processor clock was set at 16 MHz and 16MHz is 16 million cycles per second, 1ms is 0.001 seconds, therefore 16000 cycles would be 1ms. So to setup SysTick for 1ms per tick:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[\"SysTick_Config(\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"16000\"}],\");\\nSystemCoreClockUpdate();\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We need to call \",[\"$\",\"code\",null,{\"children\":\"SystemCoreClockUpdate\"}],\" because \",[\"$\",\"code\",null,{\"children\":\"SysTick_Config\"}],\" only changes the register values but \",[\"$\",\"code\",null,{\"children\":\"SystemCoreClockUpdate()\"}],\" ensures that the global variable \",[\"$\",\"code\",null,{\"children\":\"SystemCoreClock\"}],\" is updated to reflect the current core clock frequency.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"One last thing, when enabling interrupts, it's important to define their associated handlers. From the device specific \",[\"$\",\"code\",null,{\"children\":\"startup.s\"}],\" file, all interrupts handlers are declared as weak symbols that default to a \",[\"$\",\"code\",null,{\"children\":\"Default_Handler\"}],\" which is a no-op infinite loop.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-armasm\",\"children\":\"...\\n.global Default_Handler\\n\\n  ...\\n  .section .text.Default_Handler,\\\"ax\\\",%progbits\\nDefault_Handler:\\nInfinite_Loop:\\n  b Infinite_Loop\\n  .size Default_Handler, .-Default_Handler\\n\\n  ...\\n  .weak      SysTick_Handler\\n  .thumb_set SysTick_Handler,Default_Handler\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"So if SysTick is enabled and generates an interrupt without a definitive definition of \",[\"$\",\"code\",null,{\"children\":\"SysTick_Handler\"}],\", it'll hang forever. Since we've configured it to hit 0 every 1ms, simply incrementing a number every interrupt counts the milliseconds since initialization.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"volatile\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" uw_tick = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}],\";\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"void\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title function_\",\"children\":\"SysTick_Handler\"}],[\"$\",\"span\",null,{\"className\":\"hljs-params\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"void\"}],\")\"]}],\" {\\n    uw_tick++;\\n}\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"At a rate of a tick per 1 ms, it'll only overflow after 2^32 or 4,294,967,296 ms (~49.71 days). Overflow will be handled later, but since this code will be called in such a tight loop, logic will instead be put into everything that uses \",[\"$\",\"code\",null,{\"children\":\"uw_tick\"}],\".\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"GPIO configuration\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"On the nucleo board, there's a green LED, LD4 connected to PA5.\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/mb1360-g070rb_schematic__5.png\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To get that to blink, the GPIO pin needs to be configured for output. All peripherals are disabled by default, so first the GPIO clock needs to be enabled, this is managed by RCC.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[\"RCC-\u003eIOPENR |= RCC_IOPENR_GPIOAEN;\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Ensure clock is enabled by read op */\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"volatile\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" tmpreg = RCC-\u003eIOPENR \u0026 RCC_IOPENR_GPIOAEN;\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"void\"}],\") tmpreg; \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* avoid compiler warnings about unused var */\"}],\"\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The relevant global struct that deals with that is \",[\"$\",\"code\",null,{\"children\":\"GPIOA\"}],\" defined in \",[\"$\",\"code\",null,{\"children\":\"STM32CubeG0/Drivers/CMSIS/Device/ST/STM32G0xx/Include/stm32g070xx.h\"}]]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-meta\",\"children\":[\"#\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"define\"}],\" GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)\"]}],\"\\n...\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/**\\n  * @brief General Purpose I/O\\n  */\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"typedef\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-class\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\"\\n{\"]}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" MODER;       \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port mode register,               Address offset: 0x00      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" OTYPER;      \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port output type register,        Address offset: 0x04      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" OSPEEDR;     \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port output speed register,       Address offset: 0x08      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" PUPDR;       \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port pull-up/pull-down register,  Address offset: 0x0C      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" IDR;         \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port input data register,         Address offset: 0x10      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" ODR;         \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port output data register,        Address offset: 0x14      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" BSRR;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port bit set/reset  register,     Address offset: 0x18      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" LCKR;        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO port configuration lock register, Address offset: 0x1C      */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" AFR[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"2\"}],\"];      \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO alternate function registers,     Address offset: 0x20-0x24 */\"}],\"\\n  __IO \",[\"$\",\"span\",null,{\"className\":\"hljs-type\",\"children\":\"uint32_t\"}],\" BRR;         \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/*!\u003c GPIO Bit Reset register,               Address offset: 0x28      */\"}],\"\\n} GPIO_TypeDef;\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"And a basic output configuration for Port A, Pin 5:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Configure pin to be output */\"}],\" \\nGPIOA-\u003eMODER \u0026= ~GPIO_MODER_MODE5;\\nGPIOA-\u003eMODER |= GPIO_MODER_MODE5_0;\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Clear pin to make pin push-pull mode (as opposed to open drain) */\"}],\" \\nGPIOA-\u003eOTYPER \u0026= ~GPIO_OTYPER_OT5;\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* GPIO_OSPEEDR_OSPEED5_0 corresponds to `01` in bit[10:11] of OSPEEDR which means \\\"Low speed\\\"  */\"}],\"\\nGPIOA-\u003eOSPEEDR \u0026= ~GPIO_OSPEEDR_OSPEED5;\\nGPIOA-\u003eOSPEEDR |= GPIO_OSPEEDR_OSPEED5_0;\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"/* Clears the pin5 bits in PUPDR which means no pull-up or pull-down */\"}],\"\\nGPIOA-\u003ePUPDR \u0026= ~GPIO_PUPDR_PUPD5;\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Once we have this configured, we can run the following in an infinite loop to set pin 5 for a second, clear it for a second\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-C\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"while\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}],\") {\\n    GPIOA-\u003eBSRR = GPIO_BSRR_BS5;\\n    delay(\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1000\"}],\");\\n    GPIOA-\u003eBSRR = GPIO_BSRR_BR5;\\n    delay(\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1000\"}],\");\\n}\\n\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"and that blinks the light:\"}],\"\\n\",[\"$\",\"iframe\",null,{\"width\":\"560\",\"height\":\"315\",\"src\":\"https://www.youtube.com/embed/mCYVTn8uvUA\",\"frameborder\":\"0\",\"allow\":\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\",\"allowfullscreen\":true}]],null]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"2024-06-16-grow-box-part-1\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/bd17e4652862e3d3.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"RootLayout_container__tH3RP\",\"children\":[[\"$\",\"div\",null,{\"className\":\"RootLayout_masthead__LsRd7\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":[[\"$\",\"$L8\",null,{\"className\":\"RootLayout_titleLink__VQPJ9\",\"href\":\"/\",\"children\":\"eltonlaw\"}],[\"$\",\"small\",null,{\"children\":\" sundries\"}]]}],[\"$\",\"$L8\",null,{\"className\":\"RootLayout_titleLink__VQPJ9\",\"href\":\"https://github.com/eltonlaw\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 16 16\",\"width\":\"16px\",\"height\":\"16px\",\"children\":[\"$\",\"path\",null,{\"fill\":\"#828282\",\"d\":\"M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z\"}]}]}]]}],[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]]}]}]}],null]],\"initialHead\":[false,\"$L9\"],\"globalErrorComponent\":\"$a\",\"missingSlots\":\"$Wb\"}]]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"eltonlaw\"}]]\n5:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>