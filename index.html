<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Elton Law</title><meta name="description" content="Personal blog of Elton Law"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/8c61bbf7220f5504.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/8c61bbf7220f5504.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-bac2f07e2c919777.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-4b2a93ae7e555bdc.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/index-f34930dc52fc8689.js" defer="" crossorigin=""></script><script src="/_next/static/tEZ9MnZO7-QHEpRlnXEmi/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/tEZ9MnZO7-QHEpRlnXEmi/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="Home_container__d256j"><div class="Home_masthead__dbSFU"><h3><a class="Home_titleLink__W6qLi" href="/">eltonlaw</a><small> sundries</small></h3><a class="Home_titleLink__W6qLi" href="https://github.com/eltonlaw"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg></a></div><div><div class="postFrontmatter"><h2 class="PostFrontmatter_postTitle__fY2bg">Building A Custom Raspberry Pi Image - pt. 2</h2><span class="PostFrontmatter_postDate__ncWjv">2022-09-19 8:13PM</span></div>
<h4>Updating buildroot to latest stable</h4>
<p>Updating the buildroot submodule led to some issues with legacy options in my <code>.config</code>.</p>
<p>I had taken a patch that wasn&#x27;t merged into master, adding missing dependencies <code>host-libjpeg</code> and <code>host-freetype</code> to <code>QT5WEBENGINE_DEPENDENCIES</code> in <code>package/qt5/qt5webengine/qt5webengine.mk</code>. That&#x27;s in there now, so I can remove the <code>git apply</code> hotfix stuff I had.</p>
<p>The following is deprecated and was moved into a separate package</p>
<pre><code>BR2_PACKAGE_RPI_WIFI_FIRMWARE=y
</code></pre>
<p>The Raspberry Pi 3B has a Broadcom BCM43438 chip (renamed to CYW43438) which has 2.4ghz WLAN and BT 5.1 The new entries should look like</p>
<pre><code>BR2_PACKAGE_BRCMFMAC_SDIO_FIRMWARE_RPI=y
BR2_PACKAGE_BRCMFMAC_SDIO_FIRMWARE_RPI_BT=y
BR2_PACKAGE_BRCMFMAC_SDIO_FIRMWARE_RPI_WIFI=y
</code></pre>
<h4>Split into development image and release image</h4>
<p>release image will have everything required to run the QT UI and the systemd services</p>
<p>development image will be release image with some extra debug tooling. Currently,</p>
<pre><code>BR2_CCACHE=y
BR2_ENABLE_DEBUG=y
BR2_ENABLE_RUNTIME_DEBUG=y
BR2_OPTIMIZE_G=y
</code></pre>
<h4>Switching the init system to systemd</h4>
<p>From the default of busybox, I decided to switch to systemd as the init system. Busybox was easy to work with but I&#x27;m planning to have a lot of services; polling of various sensors, cloud backup, real time data analysis, etc. Maybe 10 - 20 different processes running concurrently, with some sort of IPC between them. Bringing in systemd increases the image size and complexity of the codebase but will standardize alot of the integration I think. For IPC I was planning to use DBus too, so it would fit well.</p>
<p>For certain services, <a href="http://0pointer.de/blog/projects/socket-activation.html">socket activation</a> allows for very, very fast starts. Basically, all services can be started in parallel if the sockets they output data to are initialized first before any services that consume from them are started. Then any service can start and it&#x27;ll just start queuing messages which sit there. The destination service will spin up in time and start processing the backlog. I&#x27;m planning to make all the sensor services point to a socket, it would be interesting to see how much lag time there is between pressing the power button and the first sensor measurement.
Changing it involves just adding</p>
<pre><code>BR2_INIT_SYSTEMD=y
BR2_PACKAGE_SYSTEMD=y
</code></pre>
<h4>QT can&#x27;t connect to the D-Bus session bus.</h4>
<p>Added a connect to QT session bus in the UI. Got an error</p>
<pre><code>&quot;Cannot connect to the D-Bus session bus&quot;
</code></pre>
<p>Which is because QT can&#x27;t determine the unix path of the D-BUS session bus socket filepath. This is fixable by running</p>
<pre><code>export $(dbus-launch)
</code></pre>
<p>and that just exports <code>DBUS_SESSION_BUS_ADDRESS</code> and <code>DBUS_SESSION_BUS_PID</code>.</p><div class="postFrontmatter"><h2 class="PostFrontmatter_postTitle__fY2bg">Building A Custom Raspberry Pi Image - pt. 1</h2><span class="PostFrontmatter_postDate__ncWjv">2020-12-07 4:29AM</span></div>
<p>Motivated by Jay Carlson&#x27;s <a href="https://theamphour.com/515-embedded-linux-with-jay-carlson/">Amp Hour podcast</a> and reading his blog post <a href="https://jaycarlson.net/embedded-linux/">&quot;So You Want to Build an Embedded Linux System?&quot;</a>. The following was done on a raspberry pi 3B.</p>
<p>The build system used is Buildroot. The only other alternative looked into was <a href="https://docs.yoctoproject.org/">Yocto</a> but a cursory investigation seemed to indicate that people found Buildroot easier to start up with.
Having used Buildroot a little for this project, the process does seem rather straightforward. Your final file image is entirely configured by a single <code>.config</code> file and adding packages is done by adding new directories, following certain conventions to relevant subdirectories (whether that be <code>package</code>, <code>fs</code>, <code>toolchain</code> or so on).</p>
<p>The first goal was to build and flash something working:</p>
<pre><code>$ git clone git@github.com:buildroot/buildroot.git
$ cd buildroot
$ make raspberrypi3_qt5we_defconfig
$ make
$ dd bs=5M if=output/images/sdcard.img of=/dev/sdX conv=fsync
</code></pre>
<p>The third line <code>make raspberrypi3_qt5we_defconfig</code> creates the <code>.config</code> file in the project root, being a copy of a <a href="https://github.com/buildroot/buildroot/blob/a418d0ac51e192adc54300f16b46b12a42b2b117/configs/raspberrypi3_qt5we_defconfig">predefined raspberry pi3 config with support for QT, defined in the master tree</a>. This is pretty nice as it&#x27;s something in the mainline that is guaranteed to work for the board.</p>
<p>If you followed that link, the <code>.config</code> syntax is pretty manageable, it&#x27;s a key-value format and describes things such as architecture, which SoC, root filesystem etc. This is merged with some default config file, I think, to fill in all the gaps.</p>
<pre><code>$ wc -l .config
3416 .config
$ head -10 .config
#
# Automatically generated file; DO NOT EDIT.
# Buildroot 2020.11-rc3-dirty Configuration
#
BR2_HAVE_DOT_CONFIG=y
BR2_HOST_GCC_AT_LEAST_4_9=y
BR2_HOST_GCC_AT_LEAST_5=y
BR2_HOST_GCC_AT_LEAST_6=y
BR2_HOST_GCC_AT_LEAST_7=y
BR2_HOST_GCC_AT_LEAST_8=y
</code></pre>
<p>From there, <code>make</code> is called to build the image and a bunch of files/directories are generated in <code>output/</code>. The fit-for-consumption product is located at <code>output/images/sdcard.img</code> which can be copied onto a FAT32 formatted sd card.</p>
<p>Running that, the Pi boots up into a bare bones tty. It works, hooray,</p>
<pre><code>...
Welcome to Buildroot
buildroot login: root
Password: 
# pwd
/root
# ls /
bin dev etc lib lib32 linuxrc lost+found media mnt opt proc root run sbin sys tmp usr var
</code></pre>
<h3>Adding a custom binary to the image</h3>
<p>To add a binary to the final image, I started with a simple executable:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
       printf(&quot;Goobily doo\n&quot;);
       return 0;
}
</code></pre>
<p>As mentioned above, as far as I can tell, there are two main steps: 1) creating the package and 2) enabling the package. The package creation has helper tools for different types of builds: <code>cmake-package</code>, <code>python-package</code>, <code>luarocks-package</code> and so on, which are all extensions (I think) of a <code>generic-package</code> macro. There doesn&#x27;t seem to be a process for just compiling a single C file but it&#x27;s simple to hook into the build command with something like this:</p>
<pre><code>define PI_MAIN_CONTROLLER_BUILD_CMDS
   $(TARGET_CC) -o $(@D)/pi-main-controller $(@D)/main.c
endef
</code></pre>
<p><code>$(TARGET_CC)</code> and <code>$(@D)</code> are special variables defined by Buildroot, representing the cross compiler and the build directory respectively. Very neat. About the build directory, before this <code>&lt;package_name&gt;_BUILD_CMDS</code> is run, an earlier step copies everything in <code>package/&lt;package_name&gt;/</code> to <code>output/build/&lt;package_name&gt;-&lt;version&gt;/</code>.</p>
<p>There&#x27;s another hook for after the build process to install to the target. Since this is an executable, the following sets the binary as executable and moves it to <code>output/target/usr/bin/pi-main-controller</code>.</p>
<pre><code>define PI_MAIN_CONTROLLER_INSTALL_TARGET_CMDS
   $(INSTALL) -D -m 0755 $(@D)/pi-main-controller $(TARGET_DIR)/usr/bin/pi-main-controller
endef
</code></pre>
<p>Running <code>make</code> again to rebuild:</p>
<pre><code>make 
</code></pre>
<p>If it worked correctly:</p>
<pre><code>$ ls output/target/usr/bin/pi-main-controller
output/target/usr/bin/pi-main-controller
</code></pre>
<p>From there, flashing the new image onto the sd card with that same <code>dd</code> command:</p>
<pre><code>dd bs=5M if=output/images/sdcard.img of=/dev/sdX conv=fsync
</code></pre>
<p>...then plugging that in and logging in:</p>
<pre><code>...
Welcome to Buildroot
buildroot login: root
Password: 
# pwd
/root
# pi-main-controller
Goobily doo
# 
</code></pre>
<p>There&#x27;s some working code implementing the above in this commit <a href="https://github.com/eltonlaw/pi-main-controller/commit/e24ddae64226c6dae5bd0ff7cda682444888c392">e24ddae</a>. Before reading it though, some notes:</p>
<ul>
<li>The <code>.py</code> files can be ignored as they&#x27;re just helper scripts based on the way I structured the directory.</li>
<li>For a clean separation, <code>buildroot</code> is a git submodule and the root <code>Makefile</code>&#x27;s <code>build</code> target copies all custom code and configurations from a <code>src</code> directory to their appropriate locatons.</li>
<li>The directory is structured like it is to make it simpler pulling in new commits from mainline and to easier tell what&#x27;s being customized/replaced.</li>
</ul>
<h3>Adding QT support</h3>
<p>I found a basic hello world QT application <a href="https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-setting-up-a-qt5-application-development-environment/">here</a></p>
<pre><code>#include &lt;QApplication&gt;
#include &lt;QPushButton&gt;

int main(int argc, char* argv[])
{
    QApplication app(argc, argv);
    QPushButton hello(&quot;Hello world!&quot;);
    hello.resize(100,30);
    hello.show();
    return app.exec();
}
</code></pre>
<p>and to modify Buildroot&#x27;s cross compilation toolchain to compile this, some settings need to be set. Unfortunately, I&#x27;m not familliar with it and have no clue what settings need to be set, leaving whatever <code>make raspberrypi3_qt5we_defconfig</code> created:</p>
<pre><code>BR2_PACKAGE_QT5_GL_AVAILABLE=y
BR2_PACKAGE_QT5_JSCORE_AVAILABLE=y
BR2_PACKAGE_QT5=y
BR2_PACKAGE_QT5BASE=y
BR2_PACKAGE_QT5BASE_CUSTOM_CONF_OPTS=&quot;&quot;
BR2_PACKAGE_QT5BASE_CONFIG_FILE=&quot;&quot;
BR2_PACKAGE_QT5BASE_EXAMPLES=y
BR2_PACKAGE_QT5BASE_NETWORK=y
BR2_PACKAGE_QT5BASE_SQL=y
BR2_PACKAGE_QT5BASE_SQLITE_NONE=y
BR2_PACKAGE_QT5BASE_TEST=y
BR2_PACKAGE_QT5BASE_XML=y
BR2_PACKAGE_QT5BASE_GUI=y
BR2_PACKAGE_QT5BASE_WIDGETS=y
BR2_PACKAGE_QT5BASE_OPENGL=y
BR2_PACKAGE_QT5BASE_OPENGL_ES2=y

BR2_PACKAGE_QT5BASE_EGLFS=y
BR2_PACKAGE_QT5BASE_DEFAULT_QPA=&quot;&quot;
BR2_PACKAGE_QT5BASE_PRINTSUPPORT=y
BR2_PACKAGE_QT5BASE_FONTCONFIG=y
BR2_PACKAGE_QT5BASE_GIF=y
BR2_PACKAGE_QT5BASE_JPEG=y
BR2_PACKAGE_QT5BASE_PNG=y
BR2_PACKAGE_QT5BASE_DBUS=y
BR2_PACKAGE_QT5BASE_ICU=y

BR2_PACKAGE_QT5DECLARATIVE=y
BR2_PACKAGE_QT5DECLARATIVE_QUICK=y
BR2_PACKAGE_QT5QUICKCONTROLS=y
BR2_PACKAGE_QT5QUICKCONTROLS2=y
BR2_PACKAGE_QT5SVG=y
BR2_PACKAGE_QT5WEBCHANNEL=y
BR2_PACKAGE_QT5WEBENGINE_ARCH_SUPPORTS=y
BR2_PACKAGE_QT5WEBENGINE=y
BR2_PACKAGE_QT5WEBENGINE_PROPRIETARY_CODECS=y
BR2_PACKAGE_QT5WEBSOCKETS=y
</code></pre>
<p>Apparently the build process for a QT application is involved, I see alot of apps using <code>qmake</code> or <code>cmake</code>. Here&#x27;s the full change swapping from a single C file app to using cmake <a href="https://github.com/eltonlaw/pi-main-controller/commit/2b1df298ae86ee18422f0785ae59c72688ae1768">2b1df29</a>. Swapping to <code>cmake</code> is easy. <code>CMakeLists.txt</code> is put into <code>packages/pi-main-controller</code> which will get unpacked into <code>$(@D)</code> like every other <code>cmake-packages</code> project in the mainline. The  <code>*_BUILD_CMDS</code> function is predefined so that can be removed. Last, <code>generic-package</code> is replaced with <code>cmake-package</code>. Flash it with <code>dd</code> and done. Running <code>pi-main-controller</code> opens up <code>Hello World!</code> in the center with a white background.</p></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"characters":"123"},"__N_SSG":true},"page":"/","query":{},"buildId":"tEZ9MnZO7-QHEpRlnXEmi","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>